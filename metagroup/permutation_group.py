from re import S
import numpy as np

class Cycle:
    def __init__(self, cycle_list, node_min=None, node_max=None):
        '''
        Represents a permutation with disjoint cycles, e.g, [[2,3], [1,6,7]]
        '''
        self.cycle_list = cycle_list

        self.node_min = node_min
        self.node_max = node_max
        for cycle in self.cycle_list:
            cycle = np.array(cycle)
            if np.any(cycle % np.rint(cycle) != 0):
                raise Exception("Error: All elements in cycles should be integer!")
            
            if self.node_min is None:
                self.node_min, self.node_max = np.min(cycle), np.max(cycle)

            if self.node_min > np.min(cycle):
                self.node_min = np.min(cycle)

            if self.node_max < np.max(cycle):
                self.node_max = np.max(cycle)

        self.generator = None
        self.generator = self.get_generator()

    def get_generator(self, node_min=None, node_max=None):
        '''
        Get the generator in the matrix form
        '''
        if (self.generator is not None) and (not node_min) and (not node_max):
            return self.generator

        if node_min is None:
            node_min = self.node_min

        if node_max is None:
            node_max = self.node_max

        basis = self.get_basis(node_min, node_max)
        if basis is None: # ignore identity cycle [], no element in cycle list
            return 1

        n = len(basis)
        generator = np.identity(n,dtype=int)
        for cycle in self.cycle_list:
            n_cycle = len(cycle)
            for i in range(n_cycle):
                Pi = cycle[i]
                Pj = cycle[(i+1)%n_cycle]
                indexi = Pi - node_min
                indexj = Pj - node_min
                
                if generator[indexi, indexi] == 0:
                    raise Exception("Error: Repeated integers in cycles [{0}]".format(indexi))
                else:
                    generator[indexi, indexi] = 0
                    generator[indexi, indexj] = 1

        return generator
        
    def get_basis(self, node_min=None, node_max=None):
        '''
        Get the basis notation for the generator
        '''
        if node_min is None:
            node_min = self.node_min

        if node_max is None:
            node_max = self.node_max

        if (node_min is None) or (node_max is None): # ignore identity cycle 
            return None

        return np.array(range(node_min, node_max+1),dtype=int)


class PermutationGroup:
    def __init__(self, cycles):
        '''
        Represents the group generated by cycles
        '''
        self.cycles = cycles

        self.node_min, self.node_max = None, None
        for cycle in cycles:
            default_basis = cycle.get_basis()

            if default_basis is None: # ignore identity cycle
                continue
            
            if self.node_min is None:
                self.node_min = np.min(default_basis)
                self.node_max = np.max(default_basis)
            
            if self.node_min > np.min(default_basis):
                self.node_min = np.min(default_basis)

            if self.node_max < np.max(default_basis):
                self.node_max = np.max(default_basis)

    def get_generator(self):
        generator = list()
        for cycle in self.cycles:
            generator.append(cycle.get_generator(self.node_min, self.node_max))
        return generator

    def get_elements(self):
        pass

    @property
    def order(self):
        ## Schreier–Sims algorithm
        return 0

    def coset(self, H):
        ## Todd–Coxeter algorithm and Knuth–Bendix algorithm
        pass

    def random_element(self):
        # Product-replacement algorithm 
        pass

    @property
    def subgroup(self): 
        # get all subgroups
        pass

    @property
    def quotinent(self, H):
        # get the quotient group G/H
        pass

    @property
    def product(self, H):
        # get the direct product G X H
        pass

    def get_isomorphic(self):
        pass

def get_cycles_from_list(permutation_list):
    '''
    Get cycles from the permutation list, e.g, [6,3,2,4,5,7,1] -> [2,3][1,6,7]
    The permutation list starts from 1
    '''
    n = len(permutation_list)
    label = np.zeros(n)
    cycle_lists = list()
    for i in range(len(permutation_list)):
        if label[i] == 0:
            if permutation_list[i] != i+1:
                cycle_list = list()
                cycle_list.append(i+1)
                label[i] = 1
                
                index = permutation_list[i]-1
                while label[index] == 0:
                    cycle_list.append(index+1)
                    label[index] = 1
                    index = permutation_list[index]-1

                cycle_lists.append(cycle_list)

    #print(cycle_lists)
    return Cycle(cycle_lists)

def get_PermutationGroup_by_list(permutation_list):
    cycle = get_cycles_from_list(permutation_list)
    return PermutationGroup([cycle])